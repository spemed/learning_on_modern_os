[toc]

# 存储器的抽象

## 无存储器抽象

+ 最简单，最朴素的存储器抽象就是无存储器抽象，程序员直接使用物理内存地址进行编程。

  ```assembly
  MOV AL，[0H]；将0H单元的内容传送到AL寄存器
  ```

  而操作系统一般工作在内存区域的ROM区域或者RAM区域的低层

+ 在多线程环境下，可以有多道程序在多个cpu核心上并行执行（线程本来就是共享进程的内存区域）。但是我们希望不相干的程序也能够并行的去执行，这在直接使用物理内存进行编程的存储器模型上难以做到（b程序的内存单元可能被a程序篡改导致b程序崩溃）。之前采取的策略是内存中只装载一道程序，当需要调度其他程序的时候再将内存中的程序保存到磁盘中，从磁盘中载入新的程序，通过这样的策略达到了保护的目的，但是却也失去了并行的能力。
+ 然而是不是真的就没有办法了呢，也不竟然。在IBM360机器上，将每个内存分块，并为每块内存赋予了4位的保护字（存储在寄存器中）。保护字只有操作系统能设置(在创建新进程的时候分配内存，并设置进程的PSW[程序状态字]，并为其分配到的每一块内存的保护字赋值为该进程的PSW)。当进程试图访问内存时由os去校验PSW和内存的保护字是否一致，如果不一致则拒绝访问并返回错误，这样即使是使用物理内存也能确保程序之间不产生冲突。但是这样是否就解决问题了呢？
+ 答案是否，因为该方案存在一个致命性的问题。[todo 其实还想不太明白,回头看一下]。只能通过静态重定向来解决这个问题，即是os在装载程序的时候为汇编指令中的每一句访存指令加上一个偏移量（装载程序之前内存中最后一道程序的末尾地址）。这就大大地降低了程序的执行效率了。

## 地址空间

### 什么是地址空间

+ 地址空间是进程可以访问的所有内存单元的地址的集合，每个进程的地址空间相互隔离【除非使用共享内存技术（mmap或者共享os内核中的共享区）】。是一种存储器的抽象

### 地址空间的实现

#### 基于基址寄存器的动态重定向

+ 如何实现地址空间呢，我们可以通过两个寄存器来实现，基址寄存器和界限寄存器。基址寄存器存放进程寻址的偏移量（加载该程序后该程序在内存中的起始地址），界限寄存器用于存放程序占用内存的长度。在每次访存之前，都会先比较寻址的范围是否超出界限寄存器，如果超出则返回错误并拒绝操作，未超出则将原始地址加上基址寄存器中的偏移量凭借成绝对路径进而访问到正确的物理内存单元的地址。当发生进程调度的时候，程序执行的上下文开始切换，基址寄存器和界限寄存器就会被重新设置，保证了进程之间的隔离性，而在程序内部也可以使用相对地址（起始位置为0）而没必要关心程序将会在内存中的哪个位置被加载。我们也把这种实现称之为动态重定向。
+ 有些机器的实现上不存在界限寄存器，而是采用多个基址寄存器用于计算程序被加载到内存后的起始地址和结束地址。
+ 但是这种方法也不能完美地解决所有问题。首先从效率上看，每次进行内存寻址的时候，都需要进行一次比较操作和加法操作，这让本就缓慢的访存时间（相对于cpu）更加雪上加霜。其次，虽然动态重定向解决了保护（界限寄存器）和重定位（基址寄存器）问题，但是它无法解决内存空间占用的问题。当内存中的程序数目不断增加或者某个进程不断申请内存直到需要将其移动到空间更大的内存区域的时候，就需要把内存中的其他程序（可能是处于sleep状态的程序，看操作系统的策略）一整段程序全部移动到磁盘中交换区中，本来访问内存就比cpu慢了，你还给人干一大段程序到磁盘上，这不是更慢了嘛。

#### 虚拟内存

+ 虚拟内存的出现就是为了解决保护和重定向以及增加内存的利用率。利用局部性原理，把内存分割成若干页（段），当程序开始运行时仅加载程序当前运行所需要的部分页（段）到内存中。当需要访问更多内存的时候在把新的页面加载到内存中，根据需要再淘汰老的页面。比起原先需要交换整个程序的处理，仅交换程序中的几个页面的操作大大提高了程序换入换出的效率

##### 分页

##### 分段

##### 段页式

